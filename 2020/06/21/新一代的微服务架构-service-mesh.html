<!-- 博文的布局-Layout -->
<!DOCTYPE html>
<html>
<head>
    <!-- 引入head标签 -->
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-sclable=0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="description" content="一个兴趣使然的程序员" />
<meta name="keywords" content="技术, Python, Vue, 后端开发，前端开发，日常" />
<link rel="stylesheet" href="/assets/css/bootstrap-toc.min.css">
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="stylesheet" href="/assets/css/media.css">
<link rel="stylesheet" href="/assets/css/animate.min.css">
<link rel="stylesheet" href="/assets/css/pygments/pygments_default.css">
<link rel="stylesheet" href="/assets/css/github-markdown.css">

<!-- SNS-icon -->
<script src="//at.alicdn.com/t/font_856428_y9z6nq7zf5.js"></script>
<!-- share.css -->
<link rel="stylesheet" href="/assets/css/share.min.css">
<!-- font -->
<link rel="stylesheet" href="/assets/css/font.css">
<!-- <link href="https://fonts.googleapis.com/css?family=Kaushan+Script|Pacifico|Ubuntu|Roboto+Mono|Source+Sans+Pro" rel="stylesheet"> -->

<!-- Favicon -->
<link href="/assets/images/profile.jpeg" rel="shortcut icon" />
<link href="/assets/images/profile.jpeg" rel="apple-touch-icon-precomposed" />
<!-- Android Lolipop Theme Color -->
<!-- <meta name="theme-color" content="#1464FB"> -->
<title>新一代的微服务架构 Service Mesh</title>
<!-- 百度统计 -->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?db89c93fc4343f3fa42c3534a1aaad01";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!-- 谷歌分析 -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!--  Google ADS -->
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9999308390903216",
    enable_page_level_ads: true
  });
</script>

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '');
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
<script src="/assets/js/bootstrap-toc.min.js"></script>
<!-- Mathjax Support -->
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
<script src="/assets/js/main.js"></script>
<script>
if (window.netlifyIdentity) {
  window.netlifyIdentity.on("init", function (user) {
    if (!user) {
      window.netlifyIdentity.on("login", function () {
        document.location.href = "/admin/";
      });
    }
  });
}
</script>


    <!-- Android Lolipop Theme Color -->
<meta name="theme-color" content=" rgb(37, 126, 235) ">
    
</head>
<body>

<!-- 顶部锚点 -->
<a id="htmlup" name="htmlup"></a>
<!-- 引入博文顶部选项 -->

<header id="post-header" style="background-color:rgb(37, 126, 235);">
  <div class="top-center">
      <div class="logo">
          <a href="/" title="my awesome webtitle" style="color: white;"></a>
      </div>
      <nav class="top-nav">
          <ul>
              
                <li><a href="/" style="color: white;">首页</a></li>
              
                <li><a href="/tags.html" style="color: white;">标签</a></li>
              
                <li><a href="/timeline.html" style="color: white;">时间线</a></li>
              
                <li><a href="/about.html" style="color: white;">关于博主</a></li>
              
                <li><a href="/friendLink.html" style="color: white;">友情链接</a></li>
              
          </ul>
      </nav>
      <div id="site_search">
    <input type="text" id="search-input" placeholder="Search to jump ...">
    <ul id="results-container"></ul>
</div>
<script src="/assets/js/simple-jekyll-search.min.js"></script>
<script>
if (os.isAndroid || os.isPhone) {
  $('#site_search').hide()
} else {
  var sjs = SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/search.json'
  })}
</script>
      <div id="top-boot">
        <a href="javascript:;" id="boot1" style="display:block;" onclick="document.getElementById('boot-area').style.display='block';document.getElementById('boot1').style.display='none';document.getElementById('boot2').style.display='block';"><img src="/assets/images/boot_white.png" alt=""></a>
        <a href="javascript:;" id="boot2" style="display: none;" onclick="document.getElementById('boot-area').style.display='none';document.getElementById('boot1').style.display='block';document.getElementById('boot2').style.display='none';"><img src="/assets/images/boot_white.png" alt=""></a>
      </div>
  </div>

</header>


<!-- 引入移动下拉选项 -->
<div id="boot-area">
    <ul>
        
          <a href="/"><li>首页</li></a>
        
          <a href="/tags.html"><li>标签</li></a>
        
          <a href="/timeline.html"><li>时间线</li></a>
        
          <a href="/about.html"><li>关于博主</li></a>
        
          <a href="/friendLink.html"><li>友情链接</li></a>
        
    </ul>
</div>

<!-- 引入博文顶部样式 -->
<!-- 版本一 垃圾 -->
<!-- <div class="wow fadeIn top" data-wow-duration="3.5s" >
    <span class="wow fadeInUp" data-wow-delay="0.2s">新一代的微服务架构 Service Mesh</span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;true</span>
</div> -->

<!-- 版本二 可切换页面 -->

<div class="post-top" style="background-color:rgb(37, 126, 235);">
  <!-- 页面宽度大于800px -->
  <div class="left-area">
    
    <a href="/2020/04/11/k8s-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-kubeadm-%E9%83%A8%E7%BD%B2-kubernetes-%E9%9B%86%E7%BE%A4.html" class="btn bounceInLeft animated" onmouseover="showLeft();this.style.color='rgb(37, 126, 235)';" onmouseout="goneLeft();this.style.color='rgba(0,0,0,.2)';"><</a>
    <div id="left-tab" style="display:none;"><span class="left-san"></span><span class="left-main" style="color:rgb(37, 126, 235);"><sapn class="main">「K8s 学习日记」Kubeadm 部署 kubernetes 集群</sapn></span></div>
    
  </div>
  <div class="post-titlearea">
    <span class="wow fadeInUp" data-wow-delay="0.2s">新一代的微服务架构 Service Mesh</span>
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;true</span> -->
  </div>
  <div class="right-area">
    
    <a href="/2020/10/25/k8s-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B(%E4%B8%80)%E5%9C%A8%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E6%9C%8D%E5%8A%A1.html" class="btn bounceInRight self-animated" onmouseover="showRight();this.style.color='rgb(37, 126, 235)';" onmouseout="goneRight();this.style.color='rgba(0,0,0,.2)';">></a>
    <div id="right-tab" style="display:none;"><span class="right-san"></span><span class="right-main" style="color:rgb(37, 126, 235);"><sapn class="main">K8s 快速上手（一) 在云主机上部署我的服务</sapn></span></div>
    
  </div>

  <!-- 页面宽度小于800px -->
  <div class="post-changearea">
    
    <a href="/2020/04/11/k8s-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-kubeadm-%E9%83%A8%E7%BD%B2-kubernetes-%E9%9B%86%E7%BE%A4.html" class="leftchange" style="border-right: 1px solid rgb(37, 126, 235);border-bottom: 2px solid rgb(37, 126, 235);"><span>上一篇<br><br>「K8s 学习日记」Kubeadm 部署 kubernetes 集群</span></a>
    
    
    <a href="/2020/10/25/k8s-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B(%E4%B8%80)%E5%9C%A8%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E6%9C%8D%E5%8A%A1.html" class="rightchange" style="border-left: 1px solid rgb(37, 126, 235);border-bottom: 2px solid rgb(37, 126, 235);"><span>下一篇<br><br>K8s 快速上手（一) 在云主机上部署我的服务</span></a>
    
  </div>
</div>

<div class="toc">
    <span>Toc</span>
    <nav id="toc"></nav>
</div>
<div class="markdown-body fadeInUp animated">

    
    
    <div class="postpage-subtitle"
         style="border-left: 8px solid rgb(37, 126, 235); border-right: 8px solid rgb(37, 126, 235)">
        微服务架构治理方案
    </div>
    
    
    <img src="/assets/uploads/istio-and-kubernetes-1-.webp" style="margin:auto;">
    <!-- 文章内容 -->
    <h1 id="新一代的微服务架构-service-mesh">新一代的微服务架构 Service Mesh</h1>

<p>由于最近在工作中在做 <code class="highlighter-rouge">Service Mesh</code> 的落地项目，有非常多的感触，所以想写一篇文章来分享这个「新一代的微服务架构 <code class="highlighter-rouge">Service Mesh</code>」。</p>

<p>笔者会从以下顺序开始分享：</p>

<ul>
  <li><strong>Part 1 从「单体应用架构」到「微服务架构」开始说起</strong></li>
  <li><strong>Part 2 从「Docker」到 「K8s」</strong></li>
  <li><strong>Part 3 从「边车模式」到「服务网格」</strong></li>
  <li><strong>Part 4 用「Istio Demo」来讲一个实际的应用场景</strong></li>
</ul>

<p>首先会从 「单体应用架构」 演进到 「微服务架构」 产生的问题开始说起，到自己作为开发人员感触最深的痛点。</p>

<p>然后简单介绍以下今天的主角 <code class="highlighter-rouge">Istio</code> 的服务编排环境 <code class="highlighter-rouge">Kubernetes</code>。</p>

<p>最后从 <code class="highlighter-rouge">Sidecar</code> 这种设计，说到 <code class="highlighter-rouge">Service Mesh</code>，最后到我们的主角 <code class="highlighter-rouge">Istio</code>。</p>

<p>到正式的主角之前的铺垫会比较多，这是为了让大多数开发者都能理解。</p>

<p>本文大部分内容都整理自笔者的<strong>学习资料</strong>加上自己的一些总结和体会，大家最后可以从文末找到他们。</p>

<h1 id="part-1单体应用架构到微服务架构开始说起">Part 1<strong>「单体应用架构」到「微服务架构」开始说起</strong></h1>

<h2 id="11-单体应用架构与微服务架构对比">1.1 单体应用架构与微服务架构对比</h2>

<p>从<strong>「单体」</strong>到<strong>「分布式」</strong>演进（也就是微服务化）的原因我相信大家都很了解了。</p>

<p>因为业务量越来越大，我们需要多台机器才能应对<strong>大规模的应用</strong>，所以需要<strong>垂直或者水平拆分业务系统</strong>，让其变成一个<strong>分布式的架构</strong>。</p>

<p><img src="/assets/uploads/2020-06-11-9-24-32.png" alt="" /></p>

<p>从上面的表格我们可以看到，分布式系统虽然有一些优势，但也存在一些问题。</p>

<ul>
  <li>架构设计变得复杂。</li>
  <li>部署单个服务会比较快，但是如果一次部署需要多个服务，流程会变得复杂。</li>
  <li>系统的吞吐量会变大，但是响应时间会变长。</li>
  <li>运维复杂度会因为服务变多而变得很复杂。</li>
  <li>架构复杂导致学习曲线变大。</li>
  <li>测试和查错的复杂度增大。</li>
  <li>技术多元化，公司中可能会有多个技术栈，这会带来维护和运维的复杂度。</li>
  <li>管理分布式系统中的服务和调度变得困难和复杂。</li>
</ul>

<p>作为业务开发人员<strong>最直观的感受</strong>：</p>

<ul>
  <li>接口为什么这么慢，明明只依赖了一个服务。我需要更新我的服务，但是哪些服务依赖了我的服务，这次更新会对哪些服务造成影响。</li>
  <li>我需要在代码<strong>框架层编写客户端接入监控、日志、链路追踪、告警、健康检查等各种各样非业务相关的代码</strong>。</li>
  <li><strong>测试很不方便</strong>，测试一个服务需要所有依赖的服务，测试环境资源紧张。</li>
  <li>…</li>
</ul>

<h2 id="12-微服务架构的痛点和需要解决的问题">1.2 微服务架构的痛点和需要解决的问题</h2>

<p>总结来说，微服务架构有这些痛点和需要解决的问题：</p>

<ul>
  <li>服务多，服务之间的依赖难以管理。</li>
  <li>服务之间的版本管理，不同版本的服务可能会有兼容性的问题。</li>
  <li>需要对整体架构监控，快速发现问题。</li>
  <li>资源调度管理。</li>
  <li>需要做流量控制。<strong>负载均衡、服务路由、熔断、降级、限流、灰度发布</strong>等流量相关的控制。</li>
</ul>

<p><img src="/assets/uploads/2020-06-11-9-31-25.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="https://time.geekbang.org/column/article/1512">《左耳听风 - 分布式系统技术栈》</a></p>
</blockquote>

<p>针对这么多的需要去解决和处理的问题。</p>

<p>引出了我们今天的主角 <code class="highlighter-rouge">Istio</code>。</p>

<p>在介绍我们今天的主角 <code class="highlighter-rouge">Istio</code> 之前，先简单介绍一下它的服务编排环境 <code class="highlighter-rouge">Kubernetes</code>。通过 <code class="highlighter-rouge">Docker</code> 以及其衍生出来的 <code class="highlighter-rouge">Kubernetes</code> 之类的软件或解决方案，大大地降低了做上面很多事情的门槛。</p>

<h1 id="part-2docker到-k8s">Part 2<strong>「Docker」到 「K8s」</strong></h1>

<h2 id="21-docker-容器的本质">2.1 Docker 容器的本质</h2>

<p><code class="highlighter-rouge">Docker</code> 相信大家都非常了解了，所以这里我就从 <code class="highlighter-rouge">Docker</code> 过度讲到 <code class="highlighter-rouge">k8s</code>。</p>

<p><code class="highlighter-rouge">Docker</code> 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组 <code class="highlighter-rouge">Namespace</code> 参数。这样，容器就只能<strong>“看”</strong>到当前 <code class="highlighter-rouge">Namespace</code> 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">main_function</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">,</span> <span class="n">CLONE_NEWPID</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>

<p>我们知道，在 <code class="highlighter-rouge">Linux</code> 系统中创建线程的系统调用是 <code class="highlighter-rouge">clone()</code>，就像这样。而当我们用 <code class="highlighter-rouge">clone()</code> 系统调用创建一个新进程时，就可以在参数中指定 <code class="highlighter-rouge">CLONE_NEWPID</code> 参数。这时，新创建的这个进程将会<strong>“看到”</strong>一个全新的进程空间，在这个进程空间里，它的 <code class="highlighter-rouge">PID</code> 是 <strong>1</strong>。之所以说<strong>“看到”</strong>，是因为这只是一个<strong>“障眼法”</strong>，在宿主机真实的进程空间里，这个进程的 <code class="highlighter-rouge">PID</code> 还是真实的数值，比如 <strong>100</strong>。</p>

<p>所以说，容器，其实是一种<strong>特殊的进程</strong>而已。</p>

<p>感兴趣的同学可以阅读 <a href="https://github.com/xianlubird/mydocker">《自己动手写 Docker》</a> 和尝试一下书中的代码。</p>

<h2 id="22-k8s-最小调度单位-pod">2.2 K8s 最小调度单位 Pod</h2>

<p>我花了很多精力去学习 <code class="highlighter-rouge">Linux</code> 容器的原理、理解了 <code class="highlighter-rouge">Docker</code> 容器的本质，终于, <code class="highlighter-rouge">Namespace</code> 做隔离, <code class="highlighter-rouge">Cgroups</code> 做限制, <code class="highlighter-rouge">rootfs</code> 做文件系统” 这样的“三句箴言”可以朗朗上口了。</p>

<p>为什么 <code class="highlighter-rouge">Kubernetes</code> 又突然搞出一个 <code class="highlighter-rouge">Pod</code> 来呢？</p>

<p>这里提一个概念:  <code class="highlighter-rouge">Pod</code>, 是 <code class="highlighter-rouge">Kubernetes</code> 项目中最小的 <code class="highlighter-rouge">API</code> 对象。如果换一个更专业的说法，我们可以这样描述: <code class="highlighter-rouge">Pod</code> 是 <code class="highlighter-rouge">Kubernetes</code> 项目的原子调度单位。</p>

<p>这里通过一个实际的例子来说明：</p>

<p>我们通过 <code class="highlighter-rouge">pstree</code> 查看操作系统中运行的进程，进程并不是<strong>“孤苦伶仃”</strong>地独自运行的，而是以进程组的方式，<strong>“有原则地”</strong>组织在一起。</p>

<p><img src="/assets/uploads/2020-06-11-9-50-34.png" alt="" /></p>

<p>比如，这里有一个叫作 <code class="highlighter-rouge">rsyslogd</code> 的程序，它负责的是 <code class="highlighter-rouge">Linux</code> 操作系统里的日志处理。可以看到, <code class="highlighter-rouge">rsyslogd</code> 的主程序 <code class="highlighter-rouge">main</code>, 和它要用到的内核日志模块 <code class="highlighter-rouge">imklog</code> 等，同属于 <code class="highlighter-rouge">1632</code> 进程组。这些进程相互协作，共同完成 <code class="highlighter-rouge">rsyslogd</code> 程序的职责。</p>

<p><strong>如果说 「Docker 容器」的其实就是一个「特殊的进程」。</strong></p>

<p><strong>那么「K8s」就可以理解成操作系统。</strong></p>

<p><code class="highlighter-rouge">Kubernetes</code> 所做的，其实就是将 <strong>“进程组”</strong> 的概念映射到了容器技术中，并使其成为了这个云计算 <strong>“操作系统”</strong> 里的 <strong>“原子调度单位”</strong>。</p>

<p>不过，相信此时你可能会有第二个疑问：</p>

<p>对于初学者来说，一般都是先学会了用 <code class="highlighter-rouge">Docker</code> 这种单容器的工具，才会开始接触 <code class="highlighter-rouge">Pod</code>。而如果 Pod 的设计只是出于调度上的考虑，那么 <code class="highlighter-rouge">Kubernetes</code> 项目似乎完全没有必要非得把 <code class="highlighter-rouge">Pod</code> 作为<strong>“原子调度单位”</strong>吧？</p>

<p>首先，关于 <code class="highlighter-rouge">Pod</code> 最重要的一个事实是：它只是一个<strong>逻辑概念</strong>。</p>

<p>具体的说: <code class="highlighter-rouge">Pod</code> 里的所有容器，共享的是同一个 <code class="highlighter-rouge">Network Namespace</code>，并且可以声明共享同一个 <code class="highlighter-rouge">Volume</code>。</p>

<p>那这么来看的话，一个有 <code class="highlighter-rouge">A</code> 和 <code class="highlighter-rouge">B</code> 两个容器的 <code class="highlighter-rouge">Pod</code>，不就是等同于一个容器（容器 <code class="highlighter-rouge">A</code>）共享另外一个容器（容器 <code class="highlighter-rouge">B</code>）的网络和 <code class="highlighter-rouge">Volume</code> ？这好像通过 <code class="highlighter-rouge">docker run --net --volumes-from</code> 这样的命令就能实现，就像这样。</p>

<p><img src="/assets/uploads/untitled.png" alt="" /></p>

<p>但是，你有没有考虑过，如果真这样做的话，容器 <code class="highlighter-rouge">B</code> 就必须比容器 <code class="highlighter-rouge">A</code> 先启动，这样一个 <code class="highlighter-rouge">Pod</code> 里的多个容器就不是对等关系，而是拓扑关系了。</p>

<p>所以，在 <code class="highlighter-rouge">Kubernetes</code> 项目里, <code class="highlighter-rouge">Pod</code> 的实现需要使用一个中间容器，在这个 <code class="highlighter-rouge">Pod</code> 中，中间容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 <code class="highlighter-rouge">Join Network Namespace</code> 的方式，与 中间容器关联在一起。</p>

<p><img src="/assets/uploads/untitled-1.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="https://weread.qq.com/web/reader/f57324607188b37df57c39ek8e232ec02198e296a067180">《Service Mesh 实战：用 Istio 软负载实现服务网格 3.1.3 Pause 容器》</a></p>
</blockquote>

<p><img src="/assets/uploads/untitled-2.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="https://time.geekbang.org/column/article/40092">《深入剖析Kubernetes - 为什么我们需要 Pod》</a></p>
</blockquote>

<p>如上图所示，这个 <code class="highlighter-rouge">Pod</code> 里有两个用户容器 <code class="highlighter-rouge">A</code> 和 <code class="highlighter-rouge">B</code>，还有一个中间容器容器。很容易理解，在 <code class="highlighter-rouge">Kubernetes</code> 项目里，中间容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作: <code class="highlighter-rouge">k8s.gcr.io/pause</code>。这个镜像是一个用汇编语言编写的、永远处于<strong>“暂停”</strong>状态的容器，解压后的大小也只有 <code class="highlighter-rouge">100~200 KB</code> 左右。</p>

<p>这里就不再深入说明了，感兴趣的可以点击图片链接，或者在文章末尾我列出的参考资料。</p>

<p>其中 <code class="highlighter-rouge">Pod</code> 的一个重要的特性，<strong>它的所有容器都共享同一个 Network Namespace</strong>。这就使得很多与 <code class="highlighter-rouge">Pod</code> 网络相关的配置和管理，也都可以交给 <code class="highlighter-rouge">Sidecar</code> 完成，而完全无须干涉用户容器。</p>

<p>这里最典型的例子莫过于 <code class="highlighter-rouge">Istio</code> 这个微服务治理项目了。</p>

<p>接下来就从 <code class="highlighter-rouge">Sidecar</code> 到 <code class="highlighter-rouge">Service Mesh</code> 来一步一步介绍 Istio 的设计思想。这里提到的 <code class="highlighter-rouge">Sidecar</code> 到底是什么呢, <code class="highlighter-rouge">Sidecar</code> 在国内翻译为边车模式，这个翻译真的很形象。</p>

<h1 id="part-3边车模式到服务网格">Part 3「边车模式」到「服务网格」</h1>

<h2 id="31-边车模式">3.1 边车模式</h2>

<p>所谓的<strong>边车模式</strong>，对应于我们生活中熟知的边三轮摩托车。</p>

<p><img src="/assets/uploads/untitled-3.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="https://time.geekbang.org/column/article/5909">《左耳听风 - 管理设计篇“边车模式”》</a></p>
</blockquote>

<p>我们可以通过给一个摩托车加上一个边车的方式来扩展现有的服务和功能。这样可以很容易地做到 <strong>“控制 “</strong> 和 <strong>“逻辑”</strong> 的分离。</p>

<p>也就是说，我们不需要在服务中实现控制面上的东西，如<strong>监视、日志记录、限流、熔断、服务注册、协议适配转换</strong>等这些属于控制面上的东西，而只需要专注地做好和业务逻辑相关的代码，然后，由<strong>“边车”</strong>来实现这些与业务逻辑没有关系的控制功能。</p>

<p><img src="/assets/uploads/untitled-4.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="https://time.geekbang.org/column/article/5909">《左耳听风 - 管理设计篇“边车模式”》</a></p>
</blockquote>

<p>那最终这个 <code class="highlighter-rouge">Sidecar</code> 的效果就会像上图所示。</p>

<p>那么在 <code class="highlighter-rouge">Istio</code> 中, <code class="highlighter-rouge">[Envoy](https://github.com/envoyproxy/envoy)</code> 就是默认的 <code class="highlighter-rouge">Sidecar</code>。它与服务容器在同一个 <code class="highlighter-rouge">Pod</code> 中，与服务容器共享同一个 <code class="highlighter-rouge">Network Namespace</code>，接管所有经过服务容器的流量。</p>

<p><img src="/assets/uploads/untitled-5.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="https://itnext.io/kubernetes-istio-canary-deployment-5ecfd7920e1c">《Kubernetes Istio Canary Deployment》</a></p>
</blockquote>

<h2 id="32-服务网格">3.2 服务网格</h2>

<p>然后, <code class="highlighter-rouge">Sidecar</code> 集群就成了 <code class="highlighter-rouge">Service Mesh</code>。图中的<strong>绿色模块是真实的业务应用服务</strong>，<strong>蓝色模块则是</strong> <code class="highlighter-rouge">Sidecar</code>, 其组成了一个网格。而我们的应用服务完全独立自包含，只需要和本机的 <code class="highlighter-rouge">Sidecar</code> 依赖，剩下的事全交给了 <code class="highlighter-rouge">Sidecar</code>。</p>

<p><img src="/assets/uploads/untitled-6.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="https://time.geekbang.org/column/article/5920">《左耳听风 - 管理设计篇之“服务网格”》</a></p>
</blockquote>

<p><code class="highlighter-rouge">Service Mesh</code> 这个服务网络专注于处理<strong>服务和服务间的通讯</strong>。其主要负责构造一个稳定可靠的<strong>服务通讯的基础设施</strong>，并让整个架构更为的先进和 <code class="highlighter-rouge">Cloud Native</code>。在工程中, <code class="highlighter-rouge">Service Mesh</code> 基本来说是一组<strong>轻量级的服务代理和应用逻辑的服务</strong>在一起，并且<strong>对于应用服务是透明的</strong>。</p>

<p>说白了，就是下面几个特点。</p>

<ul>
  <li><code class="highlighter-rouge">Service Mesh</code> 是一个<strong>基础设施</strong>。</li>
  <li><code class="highlighter-rouge">Service Mesh</code> 是一个<strong>轻量的服务通讯的网络代理</strong>。</li>
  <li><code class="highlighter-rouge">Service Mesh</code> 对于应用服务来说是<strong>透明无侵入</strong>的。</li>
  <li><code class="highlighter-rouge">Service Mesh</code> 用于<strong>解耦和分离分布式系统架构中控制层面</strong>上的东西。</li>
</ul>

<h2 id="33-istio-与-service-mesh">3.3 Istio 与 Service Mesh</h2>

<p>我们今天的主角 <code class="highlighter-rouge">Istio</code>，它的伟大之处不只是在设计本身，<strong>而是在于它是一个兼容并包的生态</strong>。它为整个行业提供了一种全新的开发及运维的方式。</p>

<p><img src="/assets/uploads/untitled-7.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="http://zhaohuabing/istio-practice">zhaohuabing/istio-practice</a></p>
</blockquote>

<p>微服务架构在网络链路上还有很多待解决的点，如<strong>链路跟踪、分布式日志、监控报警、压测演练、故障注入</strong>等。若让 <code class="highlighter-rouge">Istio</code> 官方来实现所有的功能，不仅耗时，还会让整个系统变得非常臃肿。</p>

<p>接下来就用 <code class="highlighter-rouge">Istio</code> 的官方 <code class="highlighter-rouge">Demo</code> 来讲一个实际的应用场景。</p>

<h1 id="part-4-用istio-demo来讲一个实际的应用场景">Part 4 <strong>用「Istio Demo」来讲一个实际的应用场景</strong></h1>

<p>这部分会用 <a href="https://istio.io/latest/zh/docs/examples/bookinfo/">Istio 官方的 Demo</a> 来演示，所以本文的大部分内容都可以在官方文档中找到。</p>

<p>如果有感兴趣的同学可以跟着这个 <code class="highlighter-rouge">Demo</code> 来实践，但是可能需要一个 <code class="highlighter-rouge">K8s</code> 集群，这里推荐使用 Google Cloud Platform 的免费试用服务 <a href="https://cloud.google.com/free">GCP Free Tier - Free Extended Trials and Always Free</a>。</p>

<p>当然如果想自己折腾搭建 <code class="highlighter-rouge">K8s</code> 集群的同学可以参考笔者的这篇文章 <a href="https://elfgzp.cn/2020/04/11/k8s-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-kubeadm-%E9%83%A8%E7%BD%B2-kubernetes-%E9%9B%86%E7%BE%A4.html">「K8s 学习日记」Kubeadm 部署 kubernetes 集群</a>。</p>

<p>但是笔者还是建议使用谷歌的服务，体验<strong>云原生</strong>的方式。</p>

<h2 id="41-istio-demobookinfo-应用服务架构">4.1 Istio Demo「Bookinfo 应用」服务架构</h2>

<p><code class="highlighter-rouge">Bookinfo</code> 应用分为四个单独的微服务：</p>

<ul>
  <li><code class="highlighter-rouge">productpage</code>. 这个微服务会调用 <code class="highlighter-rouge">details</code> 和 <code class="highlighter-rouge">reviews</code> 两个微服务，用来生成页面。</li>
  <li><code class="highlighter-rouge">details</code>. 这个微服务中包含了书籍的信息。</li>
  <li><code class="highlighter-rouge">reviews</code>. 这个微服务中包含了书籍相关的评论。它还会调用 <code class="highlighter-rouge">ratings</code> 微服务。</li>
  <li><code class="highlighter-rouge">ratings</code>. 这个微服务中包含了由书籍评价组成的评级信息。</li>
</ul>

<p><code class="highlighter-rouge">reviews</code> 微服务有 3 个版本：</p>

<ul>
  <li>v1 版本不会调用 <code class="highlighter-rouge">ratings</code> 服务。</li>
  <li>v2 版本会调用 <code class="highlighter-rouge">ratings</code> 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li>
  <li>v3 版本会调用 <code class="highlighter-rouge">ratings</code> 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li>
</ul>

<p>下图展示了这个应用的端到端架构。</p>

<p><img src="/assets/uploads/untitled-8.png" alt="" /></p>

<blockquote>
  <p>图片引用自 <a href="https://istio.io/latest/zh/docs/examples/bookinfo/">《 ISTIO 文档示例 BOOKINFO 应用》</a></p>
</blockquote>

<h2 id="42-对-reviews-v2reviews-v3-服务进行测试">4.2 对 Reviews-v2、Reviews-v3 服务进行测试</h2>

<p>在实际的应用场景中，我们当前发布了两个 <code class="highlighter-rouge">Reviews</code> 服务的 <code class="highlighter-rouge">feature</code> 版本 <code class="highlighter-rouge">v2</code> 和 <code class="highlighter-rouge">v3</code> 版本。但是如果需要对这些服务进行测试。</p>

<p>为了开发人员在测试自己开发的 <code class="highlighter-rouge">Review</code> 服务不受影响，我们可能需要部署多个完整的 <code class="highlighter-rouge">Bookinfo 应用</code> 即 <code class="highlighter-rouge">Product page</code> 、 <code class="highlighter-rouge">Ratings</code> 、 <code class="highlighter-rouge">Details</code> 的服务都需要部署，如下图所示 。</p>

<p><img src="/assets/uploads/istio_bookinfo.jpg" alt="" /></p>

<p>官方的 <code class="highlighter-rouge">BookInfo</code> 中的微服务数量还是比较少的，在实际的场景中，一个完整的系统可能会有成百上千个微服务共同支撑和运行，如果为了开发测试方便就需要庞大的服务器资源提供给微服务进行部署，这也是目前笔者公司的一个痛点。</p>

<p><img src="/assets/uploads/untitled-9.png" alt="" /></p>

<h2 id="43-利用-istio-对流量进行控制">4.3 利用 Istio 对流量进行控制</h2>

<p>在官方的 <code class="highlighter-rouge">demo</code> 中，有这样一个例子。</p>

<p>将来自名为 <code class="highlighter-rouge">Jason</code> 的用户的所有流量路由到服务 <code class="highlighter-rouge">reviews:v2</code>。将请求头中 <code class="highlighter-rouge">end-user</code> 值为 <code class="highlighter-rouge">jason</code></p>

<p>的所有请求指向 <code class="highlighter-rouge">reviews:v2</code> 。</p>

<p>正常来说，这样的功能应该需要在具体语言的 <code class="highlighter-rouge">Web</code> 框架层进行实现，但是由于 <code class="highlighter-rouge">Istio</code>  的 <code class="highlighter-rouge">Sidecar</code> 接管了所有的流量，这个功能就在 <code class="highlighter-rouge">Istio</code> 中已经集成了。</p>

<p>对于开发人员来时也就是简单的一个配置和一行命令：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">$ kubectl apply -f samples/bookinfo/networking/virtual-service-reviews-test-v2.yaml</span>
<span class="s">$ kubectl get virtualservice reviews -o yaml</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualService</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">reviews</span>
  <span class="s">...</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">hosts</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">reviews</span>
  <span class="na">http</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">match</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">headers</span><span class="pi">:</span>
        <span class="na">end-user</span><span class="pi">:</span>
          <span class="na">exact</span><span class="pi">:</span> <span class="s">jason</span>
    <span class="na">route</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">destination</span><span class="pi">:</span>
        <span class="na">host</span><span class="pi">:</span> <span class="s">reviews</span>
        <span class="na">subset</span><span class="pi">:</span> <span class="s">v2</span>
  <span class="pi">-</span> <span class="na">route</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">destination</span><span class="pi">:</span>
        <span class="na">host</span><span class="pi">:</span> <span class="s">reviews</span>
        <span class="na">subset</span><span class="pi">:</span> <span class="s">v1</span>
</code></pre></div></div>

<p>当 <code class="highlighter-rouge">Istio</code> 的流量控制放到实际的应用场景中时，测试环境就只需要一套完整的服务，和一些需要测试的不同版本的服务了。</p>

<p><img src="/assets/uploads/untitled-10.png" alt="" /></p>

<p>当然这只是其中一个应用场景，流量控制还可以用于 <code class="highlighter-rouge">A/B</code> 测试，灰度发布等。并且这只是 <code class="highlighter-rouge">Istio</code> 的其中一个功能。</p>

<p>笔者也不一一去介绍 <code class="highlighter-rouge">Istio</code> 的其他功能了，如：服务安全、链路追踪、网络拓扑、服务注册等等服务治理相关的功能，感兴趣的同学可以阅读官方文档。</p>

<p>除了官方给出的 <code class="highlighter-rouge">demo</code> ,  感兴趣的同学还可以在这个网站上找到更多的例子，<a href="https://istiobyexample.dev/">https://istiobyexample.dev/</a> 。</p>

<h1 id="结尾">结尾</h1>

<p>以上就是笔者想分享的全部内容，在这个云计算时代，笔者相信 <code class="highlighter-rouge">Service Mesh</code> 将会成为微服务架构中的一个佼佼者，帮助我们更好治理微服务架构。</p>

<h1 id="参考文献">参考文献</h1>

<ul>
  <li><a href="https://time.geekbang.org/column/intro/48">《左耳听风》陈皓</a></li>
  <li><a href="https://time.geekbang.org/column/intro/116">《深入剖析Kubernetes》张磊</a></li>
  <li><a href="https://weread.qq.com/web/reader/9fc329507191463c9fcee6d">《Kubernetes 权威指南：从 Docker 到 Kubernetest 实践全接触（第 4 版）》</a></li>
  <li><a href="https://weread.qq.com/web/reader/f57324607188b37df57c39e">《Service Mesh 实战：用 Istio 软负载实现服务网格》</a></li>
</ul>

    <!-- 引入share模块 -->
    
  <div class="social-share-wrapper">
    <div class="social-share"></div>
  </div>


<!-- share.js -->
<script src="/assets/js/social-share.min.js"></script>
<script>
  socialShare('.social-share', {
    sites: [
      
        'qq'
        ,
        
      
        'wechat'
        ,
        
      
        'weibo'
        ,
        
      
        'twitter'
        ,
        
      
        'facebook'
        
      
    ],
    wechatQrcodeTitle: "分享到微信朋友圈",
    wechatQrcodeHelper: '期待在朋友圈见到这篇文章'
  });
</script>

</div>

<!-- 底部锚点 -->
<a id="htmldown" name="htmldown"></a>
<!-- 引入评论模块 -->



    <section class="post-footer-item comment">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MDA4OS8xNjYxNg=="></div>
    </section>

    <!-- 来必力City版安装代码 -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];

           if (typeof LivereTower === 'function') { return; }

           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- City版安装代码已完成 -->





<!-- 引入goto模块 -->
<div class="bounceInRight animated go">
  <a title="顶部切换页面" class="gototop" href="#htmlup" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Top
    </div>
  </a>
  <a title="底部有livere评论哦" class="gotobottom" href="#htmldown" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Foot
    </div>
  </a>
</div>

<!-- 引入页面底部模块 -->
<footer id="bottom">
  <br>
  <span>Gzp的博客 ©
  
  
    2018
    -
  
  2020
  <a href="http://www.beian.miit.gov.cn">粤ICP备16038504号-1</a>
  <br>
  Powered by <a href="https://www.jekyll.com.cn/">Jekyll</a> | <a href="https://github.com/xukimseven/HardCandy-Jekyll">HardCandy-Jekyll</a></span>
</footer>


<!-- 引用wow.js的动画效果 -->
<script src="/assets/js/wow.js"></script>
<script>
var wow = new WOW({
  boxClass: 'wow',
  animateClass: 'animated',
  // offset: 600,
  mobile: true,
  live: true
})
wow.init()
</script>
<!-- 页面刷新回到顶部 -->
<script>
window.onbeforeunload = function () {
  //刷新后页面自动回到顶部
  document.documentElement.scrollTop = 0  //ie下
  document.body.scrollTop = 0  //非ie
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>

<link rel="stylesheet" href="/assets/css/bootstrap-toc.min.css">
<script src="/assets/js/bootstrap-toc.min.js"></script>
<script>
var navSelector = '#toc'
var $myNav = $(navSelector)

if (os.isAndroid || os.isPhone) {
  $myNav.parent().hide()
} else {
  $(function () {
    Toc.init($myNav)
    $('body').scrollspy({
      target: navSelector
    })
  })
}
</script>
<style type="text/css">

    nav[data-toggle=toc] .nav>li>a:focus,nav[data-toggle=toc] .nav>li>a:hover {
        padding-left: 19px;
        color: rgb(37, 126, 235);
        text-decoration: none;
        background-color: transparent;
        border-left: 1px solid rgb(37, 126, 235);
    }

    nav[data-toggle=toc] .nav-link.active, nav[data-toggle=toc] .nav-link.active:focus, nav[data-toggle=toc] .nav-link.active:hover {
        padding-left: 18px;
        font-weight: 700;
        color: rgb(37, 126, 235);
        background-color: transparent;
        border-left: 2px solid rgb(37, 126, 235);
    }

</style>
    <!-- Google Analytics -->
<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-126817847-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-126817847-1');
</script>
</body>
</html>
